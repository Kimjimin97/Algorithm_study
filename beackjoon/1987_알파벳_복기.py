"""
세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다.
보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 최상단 칸에는 말이 놓여잇다.

알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과 달라야한다.
즉, 같은 알파벳이 적힌 칸을 두번 지날 수 없다.
"""

"""
갈 수 잇는 깊이가 정해져 있는 문제
우리는 앞으로 알파벳 숫자만큼 이동할 수 있습니다.
그 이상은 이동할 수 없습니다.

1) 완탐 -> O(4^(N*N))
-> 시간 초과

2) bfs -> O(N*N) -> 최단경로 문제가 아니다.

3) dp -> 최대 최소 비용이 아니다

4) bfs 인데 방문 경로를 저장하고 있는 bfs라면?

5) dfs 인데 방문 경로를 저장하고 있는 dfs라면?
"""

"""
알파벳 문제의 시간 복잡도는 알파벳 26 개 이므로 
O(4^26)이다. 얼핏보면 연산횟수 10억을 넘는 것 
같지만 왔던 길은 가지 않고 지나갔던 알파벳은 
안가도 되므로 사실상 4^26의 연산이 아니라서 
시간 초과가 뜨지 않아서 DFS 로 풀어도 되는 듯 하였다.
"""


# n,m = map(int, input().split())

# graph = [
#     list(map(str, input().split(())))
#     for _ in range(n)
# ]

